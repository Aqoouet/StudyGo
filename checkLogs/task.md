# Задача: Анализ логов с фильтрацией по времени и выводом в разных форматах  

## Описание  
Реализуйте программу на Go, которая:  
- читает логи из текстового файла,  
- парсит их в структуру,  
- фильтрует по временному диапазону,  
- группирует по уровням и источникам,  
- сохраняет результаты в JSON и CSV.  

Программа должна работать с файлами, обрабатывать ошибки, использовать мапы для группировки и выводить результаты в человекочитаемом виде.  

---

## Требования к функциональности  

### 1. **Чтение файла**  
- Программа принимает путь к файлу логов.  
- Формат строки лога:  
  `timestamp | level | source | message`  
- Если файл отсутствует или пуст → возвращается ошибка.  

### 2. **Парсинг логов**  
- Каждая строка лога преобразуется в структуру:  
  ```go
  type LogEntry struct {
      Timestamp string
      Level     string
      Source    string
      Message   string
  }
  ```
- Некорректные строки игнорируются с предупреждением.  

### 3. **Фильтрация по временному диапазону**  
- Пользователь указывает начало и конец периода (в формате `"2006-01-02 15:04:05"`).  
- Логи, где `timestamp` выходит за рамки диапазона, исключаются.  
- Если формат времени неверен → возвращается ошибка.  

### 4. **Группировка по уровням и источникам**  
- Подсчёт количества записей по уровням логов (`INFO`, `ERROR`, `DEBUG`, `WARN` и др.).  
- Группировка записей по источникам (`app`, `db`, `api` и т.д.).  

### 5. **Сохранение результатов в файл**  
- Поддержка вывода в JSON и CSV.  
- Если формат не поддерживается → ошибка.  
- Файл сохраняется по указанному пути.  

### 6. **Вывод статистики в консоль**  
- Выводит:  
  - количество логов по уровням,  
  - список источников с количеством записей,  
  - количество записей после фильтрации.  

---

## Дополнительные условия  

### 1. **Обработка ошибок**  
- Если файл отсутствует → `"Ошибка: файл не найден"`.  
- Если формат временной метки неверен → `"Ошибка: неверный формат времени"`.  
- Если формат вывода не поддерживается → `"Ошибка: формат %s не поддерживается"`.  
- Предупреждения о некорректных строках: `"Строка %d пропущена — неверный формат"`.  

### 2. **Формат временных меток**  
- Временные метки в логах могут быть в разных форматах:  
  - `"2023-10-05 14:30:00"`  
  - `"2023-10-05T14:30:00Z"`  
- Программа должна корректно обрабатывать все допустимые форматы.  

### 3. **Группировка по источникам**  
- Источники могут быть произвольными (например, `"scheduler"`, `"worker"`).  
- Результат — мапа `map[string][]LogEntry`, где ключ — источник, значение — список логов.  

### 4. **Фильтрация по периоду**  
- Время в логах сравнивается с заданным периодом.  
- Если временная метка не может быть распарсена → лог игнорируется.  

### 5. **Форматы вывода**  
#### JSON  
- Слайс структур `[]LogEntry`.  
- Пример:  
  ```json
  [
    {"timestamp": "2023-10-05 14:30:00", "level": "INFO", "source": "app", "message": "Пользователь авторизовался"},
    {"timestamp": "2023-10-05 14:35:00", "level": "ERROR", "source": "db", "message": "База данных недоступна"}
  ]
  ```  

#### CSV  
- Заголовки: `timestamp,level,source,message`.  
- Пример:  
  ```csv
  timestamp,level,source,message
  2023-10-05 14:30:00,INFO,app,Пользователь авторизовался
  2023-10-05 14:35:00,ERROR,db,База данных недоступна
  ```  

---

## Краевые случаи  

| Ситуация | Описание |
|----------|----------|
| Пустой файл | Выводится `"Ошибка: файл пуст"` |
| Все записи вне диапазона | Результаты JSON и CSV создаются, но пустые |
| Некорректный формат строки | Строка игнорируется, выводится предупреждение |
| Одинаковые временные метки | Все записи учитываются |
| Дубликаты | Учитываются как отдельные записи |
| Нестандартные уровни логов | Уровни сохраняются как есть |
| Спецсимволы в сообщениях | Корректно обрабатываются в JSON/CSV |
| Файл с правами только на чтение | Обработка ошибок ввода/вывода |

---

## Требования к реализации  

### 1. **Методы и структуры**  
- Используйте структуру `LogAnalyzer` с методами:  
  ```go
  type LogAnalyzer struct {
      Logs []LogEntry
  }
  ```
  Методы:  
  ```go
  func NewLogAnalyzer(filePath string) (*LogAnalyzer, error)
  func (la *LogAnalyzer) FilterByPeriod(start, end string) ([]LogEntry, error)
  func (la *LogAnalyzer) CountByLevel() map[string]int
  func (la *LogAnalyzer) GroupBySource() map[string][]LogEntry
  func (la *LogAnalyzer) SaveToFile(filename, format string) error
  func PrintStats(stats map[string]int)
  ```  

### 2. **Обработка ошибок**  
- Используйте встроенные ошибки (например, `os.ErrNotExist`).  
- Реализуйте пользовательские ошибки:  
  - `"Ошибка: файл не найден"`  
  - `"Ошибка: неверный формат: %s"`  
  - `"Ошибка: формат %s не поддерживается"`  

### 3. **Файловый ввод/вывод**  
- Чтение: `os.ReadFile()`  
- Запись: `os.WriteFile()` или `os.Create()`  

### 4. **Форматирование вывода**  
- Используйте `fmt.Printf` для консоли.  
- Для CSV: `encoding/csv`.  
- Для JSON: `encoding/json`.  

---

## Усложнения (по желанию)  

| Уровень | Что можно добавить |
|--------|-------------------|
| **Middle** | Поддержка нескольких файлов, CLI-интерфейс |
| **Strong Middle** | Сортировка логов по времени, обработка относительных временных меток |
| **Junior+** | Интеграция с HTTP-сервером для получения логов |

---

## Что проверяется  

| Тема | Как используется |
|------|------------------|
| Переменные | Хранение логов, временных меток, статистики |
| Типы данных | Структура `LogEntry`, мапы, слайсы |
| Вывод на экран | Отладка, статистика в консоли |
| Условный оператор | Проверка форматов, обработка ошибок |
| Циклы | Парсинг логов, фильтрация, группировка |
| Массивы и слайсы | Хранение логов, обработка временного диапазона |
| Мапы | Подсчёт уровней и группировка по источникам |
| Методы | Реализация `LogAnalyzer` с методами |
| Ошибки | Обработка файлов, временных меток, форматов вывода |
| Файловый ввод/вывод | Чтение логов, сохранение результатов |

---

## Пример вызова программы  

```go
analyzer, _ := NewLogAnalyzer("logs.txt")
filtered, _ := analyzer.FilterByPeriod("2023-10-05 14:30:00", "2023-10-05 14:40:00")
stats := analyzer.CountByLevel()
groups := analyzer.GroupBySource()
analyzer.SaveToFile("output.json", "json")
analyzer.SaveToFile("output.csv", "csv")
PrintStats(stats)
```  

---

## Итог  
Эта задача проверяет:  
- Работу с файлами и временными метками,  
- Использование мап и слайсов для группировки,  
- Обработку ошибок,  
- Форматирование вывода.  

Если хотите, могу предоставить эталонное решение или тесты к этой задаче.

# Обработка и вывод ошибок в задаче  

## Куда выводить ошибки?  

### 1. **Консоль**  
Все **критические ошибки** и **предупреждения** выводятся в `os.Stderr` (стандартный поток ошибок):  
- Ошибки чтения/записи файлов.  
- Неверный формат времени.  
- Неподдерживаемый формат вывода.  
- Некорректные строки в файле.  

Пример:  
```go
fmt.Fprintln(os.Stderr, "Ошибка: файл не найден")
fmt.Fprintln(os.Stderr, "Предупреждение: строка 2 пропущена — неверный формат")
```

### 2. **Возврат из функций**  
Для **некритических ошибок** (например, некорректные строки) — возвращайте ошибки из функций:  
```go
func ParseLogs(data []byte) ([]LogEntry, error)
```
Используйте:  
- `fmt.Errorf("неверный формат: %s", line)` — для детализации.  
- `errors.New("файл пуст")` — для простых ошибок.  

### 3. **Логирование в файл (по желанию)**  
Если требуется сохранять ошибки в файл (например, для аудита):  
- Создайте отдельный файл `errors.log`.  
- Используйте `os.OpenFile()` и `io.MultiWriter()` для дублирования ошибок в консоль и файл.  

---

## Примеры обработки ошибок  

### Ошибка чтения файла  
```go
if err != nil {
    fmt.Fprintf(os.Stderr, "Ошибка: %v\n", err)
    os.Exit(1)
}
```

### Некорректная строка в файле  
```go
fmt.Fprintf(os.Stderr, "Предупреждение: строка %d пропущена — неверный формат\n", lineNumber)
```

### Неверный формат времени  
```go
return nil, fmt.Errorf("ошибка парсинга времени: %s", err.Error())
```

### Неподдерживаемый формат вывода  
```go
return fmt.Errorf("формат %s не поддерживается", format)
```

---

## Рекомендации  

| Ошибка | Куда выводить | Как обрабатывать |
|--------|----------------|------------------|
| Файл не найден | Консоль (`os.Stderr`) | `fmt.Errorf("файл не найден: %s", path)` |
| Пустой файл | Консоль | `fmt.Fprintln(os.Stderr, "Ошибка: файл пуст")` |
| Неверный формат строки | Консоль | `fmt.Fprintf(os.Stderr, "Предупреждение: строка %d пропущена — неверный формат", i)` |
| Неверный формат времени | Консоль + возврат | `fmt.Errorf("неверный формат времени: %s", err.Error())` |
| Неподдерживаемый формат вывода | Консоль | `fmt.Errorf("формат %s не поддерживается", format)` |
| Ошибка записи в файл | Консоль | `fmt.Fprintf(os.Stderr, "Ошибка сохранения: %v", err)` |

---

## Важно  
- **Критические ошибки** (например, отсутствие файла) — завершают программу с кодом `os.Exit(1)`.  
- **Предупреждения** (например, некорректные строки) — выводятся в консоль, но программа продолжает работу.  
- **Человекочитаемые сообщения** — должны быть понятны пользователю и содержать контекст (номер строки, формат времени и т.д.).  
- **Стандартные практики Go** — используйте `error` и проверяйте её через `if err != nil`.  

--- 

## Итог  
Сообщения об ошибках выводите в `os.Stderr`, чтобы отделить от обычного вывода.  
Используйте `fmt.Fprintln`, `fmt.Fprintf` и возврат `error` для гибкой обработки.  
Предупреждения о некорректных данных (например, неверный формат строки) — выводите в консоль, но **не останавливайте программу**.  

Если хотите, могу показать реализацию обработки ошибок в коде.
